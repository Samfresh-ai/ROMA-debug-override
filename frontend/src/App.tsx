import { useEffect, useMemo, useState } from 'react';
import { Header } from './components/Header';
import { LogPasteArea } from './components/LogPasteArea';
import { FixDisplay } from './components/FixDisplay';
import {
  analyzeError,
  AnalyzeResponse,
  githubAnalyzeRepo,
  githubApplyPatchBatch,
  githubCommit,
  githubCloneRepo,
  githubListRepos,
  githubLogout,
  githubOpenPr,
  githubOAuthExchange,
  githubOAuthStart,
} from './services/api';

function App() {
  const [isLoading, setIsLoading] = useState(false);
  const [result, setResult] = useState<AnalyzeResponse | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [githubSessionId, setGithubSessionId] = useState<string | null>(null);
  const [repoUrl, setRepoUrl] = useState('');
  const [repoRef, setRepoRef] = useState('');
  const [repoId, setRepoId] = useState<string | null>(null);
  const [isCloning, setIsCloning] = useState(false);
  const [defaultBranch, setDefaultBranch] = useState('main');
  const [repos, setRepos] = useState<Array<{ full_name: string; html_url: string }>>([]);
  const [useRepoAnalysis, setUseRepoAnalysis] = useState(false);
  const [pendingPatch, setPendingPatch] = useState<AnalyzeResponse | null>(null);
  const [branchName, setBranchName] = useState('roma-fix');
  const [commitMessage, setCommitMessage] = useState('ROMA Debug fixes');
  const [prTitle, setPrTitle] = useState('ROMA Debug fixes');
  const [prBody, setPrBody] = useState('Automated fixes generated by ROMA Debug.');
  const [prUrl, setPrUrl] = useState<string | null>(null);
  const [confirmOpen, setConfirmOpen] = useState(false);
  const [pendingPatchCount, setPendingPatchCount] = useState(0);

  const oauthCode = useMemo(() => {
    const params = new URLSearchParams(window.location.search);
    return params.get('code');
  }, []);

  useEffect(() => {
    const exchangeCode = async () => {
      if (!oauthCode || githubSessionId) return;
      try {
        const resp = await githubOAuthExchange(oauthCode);
        setGithubSessionId(resp.session_id);
        const repoResp = await githubListRepos(resp.session_id);
        setRepos(repoResp.repos.map((r) => ({ full_name: r.full_name, html_url: r.html_url })));
        const url = new URL(window.location.href);
        url.searchParams.delete('code');
        window.history.replaceState({}, document.title, url.toString());
      } catch (err) {
        setError(err instanceof Error ? err.message : 'GitHub OAuth failed');
      }
    };
    exchangeCode();
  }, [oauthCode, githubSessionId]);

  const handleSubmit = async (log: string) => {
    setIsLoading(true);
    setError(null);
    setResult(null);
    setPrUrl(null);

    try {
      if (useRepoAnalysis && repoId && githubSessionId) {
        const response = await githubAnalyzeRepo(repoId, githubSessionId, log);
        setResult(response);
        setPendingPatch(response);
      } else {
        const response = await analyzeError(log);
        setResult(response);
        setPendingPatch(null);
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred');
    } finally {
      setIsLoading(false);
    }
  };

  const handleConnectGithub = async () => {
    setError(null);
    try {
      const resp = await githubOAuthStart();
      window.location.href = resp.authorize_url;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to start GitHub OAuth');
    }
  };

  const handleDisconnectGithub = async () => {
    try {
      if (githubSessionId) {
        await githubLogout(githubSessionId);
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to disconnect GitHub');
    } finally {
      setGithubSessionId(null);
      setRepos([]);
      setRepoUrl('');
      setRepoRef('');
      setRepoId(null);
      setUseRepoAnalysis(false);
      setPendingPatch(null);
      setPrUrl(null);
    }
  };

  const handleCloneRepo = async () => {
    if (!githubSessionId || !repoUrl.trim()) {
      setError('Connect GitHub and provide a repository URL');
      return;
    }
    setIsCloning(true);
    setError(null);
    try {
      const resp = await githubCloneRepo(repoUrl.trim(), githubSessionId, repoRef.trim() || undefined);
      setRepoId(resp.repo_id);
      setDefaultBranch(resp.default_branch || 'main');
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to clone repo');
    } finally {
      setIsCloning(false);
    }
  };

  const handleApplyAndPr = async () => {
    if (!pendingPatch || !pendingPatch.filepath || !githubSessionId || !repoId) {
      setError('No patch to apply or missing repo session');
      return;
    }
    const patchList = [
      { filepath: pendingPatch.filepath, code: pendingPatch.code },
      ...(pendingPatch.additional_fixes || []).map((fix) => ({
        filepath: fix.filepath,
        code: fix.code,
      })),
    ].filter((p) => p.filepath && p.code && p.code.trim());

    if (patchList.length === 0) {
      setError('No valid patches to apply');
      return;
    }

    setPendingPatchCount(patchList.length);
    setConfirmOpen(true);
  };

  const confirmApplyAndPr = async () => {
    if (!pendingPatch || !pendingPatch.filepath || !githubSessionId || !repoId) {
      setError('No patch to apply or missing repo session');
      setConfirmOpen(false);
      return;
    }
    const patchList = [
      { filepath: pendingPatch.filepath, code: pendingPatch.code },
      ...(pendingPatch.additional_fixes || []).map((fix) => ({
        filepath: fix.filepath,
        code: fix.code,
      })),
    ].filter((p) => p.filepath && p.code && p.code.trim());
    if (patchList.length === 0) {
      setError('No valid patches to apply');
      setConfirmOpen(false);
      return;
    }

    try {
      await githubApplyPatchBatch(
        repoId,
        githubSessionId,
        patchList.map((p) => ({ filepath: p.filepath, content: p.code })),
      );
      await githubCommit(repoId, githubSessionId, branchName, commitMessage);
      const resp = await githubOpenPr(repoId, githubSessionId, branchName, prTitle, prBody);
      setPrUrl(resp.pr_url || null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to create PR');
    } finally {
      setConfirmOpen(false);
    }
  };

  return (
    <div className="min-h-screen bg-gray-50 flex flex-col">
      <Header />

      <main className="flex-1 max-w-5xl w-full mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <div className="space-y-8">
          {/* GitHub Repo Section */}
          <section className="bg-white rounded-xl shadow-sm border border-gray-200 p-6 space-y-4">
            <div className="flex items-center justify-between">
              <div>
                <h2 className="text-lg font-semibold text-gray-800">GitHub Repo</h2>
                <p className="text-sm text-gray-500">Connect GitHub to analyze a private repo.</p>
              </div>
              <div className="flex items-center space-x-2">
                <button
                  type="button"
                  onClick={handleConnectGithub}
                  className="px-4 py-2 text-sm font-medium text-white bg-gray-900
                             rounded-lg hover:bg-gray-800 transition-colors"
                >
                  {githubSessionId ? 'GitHub Connected' : 'Connect GitHub'}
                </button>
                {githubSessionId && (
                  <button
                    type="button"
                    onClick={handleDisconnectGithub}
                    className="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100
                               rounded-lg hover:bg-gray-200 transition-colors"
                  >
                    Disconnect
                  </button>
                )}
              </div>
            </div>

            <div className="grid grid-cols-1 gap-3 sm:grid-cols-3">
              <select
                value={repoUrl}
                onChange={(e) => setRepoUrl(e.target.value)}
                className="sm:col-span-2 px-3 py-2 border border-gray-300 rounded-lg text-sm"
              >
                <option value="">Select a repo...</option>
                {repos.map((r) => (
                  <option key={r.html_url} value={r.html_url}>
                    {r.full_name}
                  </option>
                ))}
              </select>
              <input
                type="text"
                value={repoRef}
                onChange={(e) => setRepoRef(e.target.value)}
                placeholder="branch or tag (optional)"
                className="px-3 py-2 border border-gray-300 rounded-lg text-sm"
              />
            </div>

            <div className="flex items-center justify-between">
              <div className="text-sm text-gray-500">
                {repoId ? `Repo ready: ${repoId}` : 'Repo not cloned yet'}
              </div>
              <button
                type="button"
                onClick={handleCloneRepo}
                disabled={!githubSessionId || isCloning}
                className="px-4 py-2 text-sm font-medium text-white bg-roma-primary
                           rounded-lg hover:bg-blue-600 disabled:opacity-50"
              >
                {isCloning ? 'Cloning...' : 'Clone Repo'}
              </button>
            </div>

            <label className="flex items-center space-x-2 text-sm text-gray-700">
              <input
                type="checkbox"
                checked={useRepoAnalysis}
                onChange={(e) => setUseRepoAnalysis(e.target.checked)}
              />
              <span>Use cloned repo for analysis</span>
            </label>
          </section>

          {/* Input Section */}
          <section className="bg-white rounded-xl shadow-sm border border-gray-200 p-6">
            <LogPasteArea onSubmit={handleSubmit} isLoading={isLoading} />
          </section>

          {/* Error Display */}
          {error && (
            <div className="bg-red-50 border border-red-200 rounded-lg p-4">
              <div className="flex items-center">
                <svg className="w-5 h-5 text-red-500 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2}
                        d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                <span className="text-red-700 font-medium">Error</span>
              </div>
              <p className="mt-2 text-red-600">{error}</p>
            </div>
          )}

          {/* Result Section */}
          {result && (
            <section className="bg-white rounded-xl shadow-sm border border-gray-200 p-6">
              <h2 className="text-lg font-semibold text-gray-800 mb-4 flex items-center">
                <svg className="w-5 h-5 mr-2 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2}
                        d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                {result.filepath ? 'Fix Available' : 'General Advice'}
              </h2>
              <FixDisplay
                code={result.code}
                explanation={result.explanation}
                filepath={result.filepath}
                diff={result.diff || undefined}
                additionalFixes={result.additional_fixes || []}
                filesRead={result.files_read}
                filesReadSources={result.files_read_sources}
              />

              {useRepoAnalysis && pendingPatch?.filepath && (
                <div className="mt-6 space-y-3">
                  <div className="text-sm text-gray-600">
                    Ready to apply {1 + (pendingPatch.additional_fixes?.length || 0)} patch(es) and open a PR?
                  </div>
                  <div className="text-sm text-gray-500">
                    Files: {[pendingPatch.filepath, ...(pendingPatch.additional_fixes || []).map((f) => f.filepath)].join(', ')}
                    {defaultBranch ? ` | Base: ${defaultBranch}` : ''}
                  </div>
                  <div className="grid grid-cols-1 gap-3 sm:grid-cols-2">
                    <input
                      type="text"
                      value={branchName}
                      onChange={(e) => setBranchName(e.target.value)}
                      placeholder="branch name"
                      className="px-3 py-2 border border-gray-300 rounded-lg text-sm"
                    />
                    <input
                      type="text"
                      value={commitMessage}
                      onChange={(e) => setCommitMessage(e.target.value)}
                      placeholder="commit message"
                      className="px-3 py-2 border border-gray-300 rounded-lg text-sm"
                    />
                    <input
                      type="text"
                      value={prTitle}
                      onChange={(e) => setPrTitle(e.target.value)}
                      placeholder="PR title"
                      className="px-3 py-2 border border-gray-300 rounded-lg text-sm"
                    />
                    <input
                      type="text"
                      value={prBody}
                      onChange={(e) => setPrBody(e.target.value)}
                      placeholder="PR body"
                      className="px-3 py-2 border border-gray-300 rounded-lg text-sm"
                    />
                  </div>
                  <button
                    type="button"
                    onClick={handleApplyAndPr}
                    className="px-4 py-2 text-sm font-medium text-white bg-green-600
                               rounded-lg hover:bg-green-700 transition-colors"
                  >
                    Apply Patch + Open PR
                  </button>
                  {prUrl && (
                    <div className="text-sm text-green-700">
                      PR created: {prUrl}
                    </div>
                  )}
                </div>
              )}
            </section>
          )}
        </div>
      </main>

      {confirmOpen && (
        <div className="fixed inset-0 bg-black/40 flex items-center justify-center z-50">
          <div className="bg-white rounded-xl shadow-lg border border-gray-200 p-6 w-full max-w-md">
            <div className="text-lg font-semibold text-gray-800 mb-2">Confirm PR</div>
            <div className="text-sm text-gray-600 mb-4">
              Apply {pendingPatchCount} patch(es) and create a PR?
            </div>
            <div className="flex justify-end space-x-2">
              <button
                type="button"
                onClick={() => setConfirmOpen(false)}
                className="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100
                           rounded-lg hover:bg-gray-200"
              >
                Cancel
              </button>
              <button
                type="button"
                onClick={confirmApplyAndPr}
                className="px-4 py-2 text-sm font-medium text-white bg-green-600
                           rounded-lg hover:bg-green-700"
              >
                Confirm
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Footer */}
      <footer className="py-6 text-center text-gray-500 text-sm border-t border-gray-200">
        <p>ROMA Debug - Powered by Gemini</p>
      </footer>
    </div>
  );
}

export default App;
